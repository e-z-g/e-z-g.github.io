<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Cubemap VR</title>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Cubemap VR">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#000000">

  <link rel="apple-touch-icon" href="https://photo-sphere-viewer-data.netlify.app/assets/loader.gif">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@photo-sphere-viewer/core@5/index.min.css" />

  <style>
    body, html {
      margin: 0; padding: 0;
      width: 100%;
      height: 100vh;
      height: 100dvh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #000;
    }
    #viewer { width: 100%; height: 100%; }
    .ui-container {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: 50%;
      transform: translateX(-50%);
      display: flex; flex-direction: column;
      align-items: center; gap: 10px;
      z-index: 101; width: 100%;
      pointer-events: none;
    }
    .controls-row {
      display: flex; gap: 10px;
      background: rgba(20,20,20,0.85);
      border-radius: 12px; padding: 8px 16px;
      pointer-events: auto;
      backdrop-filter: blur(15px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.1);
    }
    button, select {
      background: #558CFE; color: white;
      border: none; border-radius: 6px;
      font-size: 14px; font-weight: bold;
      padding: 10px 16px; cursor: pointer;
      outline: none; transition: background 0.2s;
    }
    button.active { background: #2259E8; }
    select {
      appearance: none; padding-right: 34px;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 12px top 50%;
      background-size: 10px auto;
    }
    #caption {
      position: absolute; left: 50%;
      transform: translateX(-50%);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 54px);
      z-index: 100;
      background: rgba(0,0,0,0.7); color: #fff;
      padding: 10px 20px; border-radius: 8px;
      font-size: 13px; font-weight: 500;
      max-width: 85vw; text-align: center;
      line-height: 1.4; pointer-events: none;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "@photo-sphere-viewer/core": "https://cdn.jsdelivr.net/npm/@photo-sphere-viewer/core@5/index.module.js",
      "@photo-sphere-viewer/cubemap-adapter": "https://cdn.jsdelivr.net/npm/@photo-sphere-viewer/cubemap-adapter@5/index.module.js",
      "@photo-sphere-viewer/gyroscope-plugin": "https://cdn.jsdelivr.net/npm/@photo-sphere-viewer/gyroscope-plugin@5/index.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="viewer"></div>

  <div class="ui-container">
    <div class="controls-row">
      <label style="color:white;font-size:11px;align-self:center;font-weight:bold;text-transform:uppercase;opacity:0.8;margin-right:4px;">Location</label>
      <select id="location-selector"></select>
    </div>
    <div id="quality-buttons" class="controls-row"></div>
  </div>

  <div id="caption">
    This product was created using artwork with ™ and/or © works of Cyan. All rights reserved by Cyan. This product is not official and is not endorsed by Cyan.
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { Viewer } from '@photo-sphere-viewer/core';
    import { CubemapAdapter } from '@photo-sphere-viewer/cubemap-adapter';
    import { GyroscopePlugin } from '@photo-sphere-viewer/gyroscope-plugin';

    const rawUrl = 'https://raw.githubusercontent.com/e-z-g/e-z-g.github.io/main/';

    // Added audio URLs (Swap these with your actual audio files)
    const locations = [
      {
        name: 'Amateria',
        baseUrl: rawUrl + 'vr2/',
        type: 'side-numbered',
        audio: 'https://raw.githubusercontent.com/e-z-g/e-z-g.github.io/main/cubemapvr/audio_amateria.mp3',
        versions: [
          { label: 'Original',    suffix: '_orig.jpeg' },
          { label: 'Color Match', suffix: '_colormatch.webp' },
          { label: 'Seamless',    suffix: '_seamless.webp' }
        ]
      },
      {
        name: 'J\'nanin',
        baseUrl: rawUrl + 'cubemapvr/',
        type: 'classic-leis',
        audio: 'https://raw.githubusercontent.com/e-z-g/e-z-g.github.io/main/cubemapvr/audio_jnanin.mp3',
        versions: [
          { label: 'Original', suffix: '-orig.jpg' },
          { label: 'HD Mod',   suffix: '-hdmod.webp' },
          { label: '4K',       suffix: '-4096.jpg',     mobileOnly: true },
          { label: '24K',      suffix: '-seamless.webp', desktopOnly: true }
        ]
      }
    ];

    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    let currentLocation = locations[0];
    let currentVersionIndex = 0;
    let isTransitioning = false;

    // --- Audio System ---
    const audioSystem = {
      active: new Audio(),
      fading: new Audio(),
      isUnlocked: false,
      currentUrl: null
    };

    audioSystem.active.loop = true;
    audioSystem.fading.loop = true;

    function unlockAudio() {
      if (audioSystem.isUnlocked) return;
      audioSystem.isUnlocked = true;
      document.removeEventListener('pointerdown', unlockAudio);
      if (audioSystem.currentUrl) {
        playOrCrossfadeAudio(audioSystem.currentUrl);
      }
    }
    document.addEventListener('pointerdown', unlockAudio);

    function playOrCrossfadeAudio(newUrl) {
      if (!newUrl || audioSystem.currentUrl === newUrl) return;
      audioSystem.currentUrl = newUrl;
      
      if (!audioSystem.isUnlocked) return;

      const temp = audioSystem.fading;
      audioSystem.fading = audioSystem.active;
      audioSystem.active = temp;

      audioSystem.active.src = newUrl;
      audioSystem.active.volume = 0;
      audioSystem.active.play().catch(e => console.warn('Audio blocked:', e));

      const steps = 20;
      let step = 0;

      const fade = setInterval(() => {
        step++;
        const progress = step / steps;
        
        audioSystem.active.volume = progress;
        
        if (audioSystem.fading.src) {
          audioSystem.fading.volume = Math.max(0, 1 - progress);
        }

        if (step >= steps) {
          clearInterval(fade);
          if (audioSystem.fading.src) {
            audioSystem.fading.pause();
            audioSystem.fading.src = ''; 
          }
        }
      }, 1000 / steps);
    }

    // --- Fullscreen transition overlay ---
    const transitionScene  = new THREE.Scene();
    const transitionCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    let transitionMesh = null;
    let rtOld = null;
    let rtNew = null;

    const VERT = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    `;

    const FRAG_BLOCK = `
      uniform sampler2D tOld;
      uniform sampler2D tNew;
      uniform float uProgress;
      uniform float uBlockSize;
      uniform float uAspect;
      varying vec2 vUv;

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      void main() {
        vec2 correctedUv = vec2(vUv.x * uAspect, vUv.y);
        vec2 blockUv = floor(correctedUv * uBlockSize) / uBlockSize;
        float r = hash(blockUv);
        if (smoothstep(0.0, 1.0, uProgress) > r) {
          gl_FragColor = texture2D(tNew, vUv);
        } else {
          gl_FragColor = texture2D(tOld, vUv);
        }
      }
    `;

    const FRAG_FADE = `
      uniform sampler2D tOld;
      uniform sampler2D tNew;
      uniform float uProgress;
      varying vec2 vUv;

      void main() {
        vec4 a = texture2D(tOld, vUv);
        vec4 b = texture2D(tNew, vUv);
        gl_FragColor = mix(a, b, smoothstep(0.0, 1.0, uProgress));
      }
    `;

    // --- Helpers ---

    function getActiveVersions(loc) {
      return loc.versions.filter(v => {
        if (v.desktopOnly && isMobile)  return false;
        if (v.mobileOnly  && !isMobile) return false;
        return true;
      });
    }

    function getCubemap(loc, version) {
      if (loc.type === 'side-numbered') {
        return {
          front:  loc.baseUrl + 'MAWWnodes-8'  + version.suffix,
          bottom: loc.baseUrl + 'MAWWnodes-9'  + version.suffix,
          back:   loc.baseUrl + 'MAWWnodes-10' + version.suffix,
          right:  loc.baseUrl + 'MAWWnodes-11' + version.suffix,
          left:   loc.baseUrl + 'MAWWnodes-12' + version.suffix,
          top:    loc.baseUrl + 'MAWWnodes-13' + version.suffix,
        };
      } else {
        const s = version.suffix;
        return {
          left:   loc.baseUrl + 'LEIS665' + s,
          front:  loc.baseUrl + 'LEIS661' + s,
          right:  loc.baseUrl + 'LEIS664' + s,
          back:   loc.baseUrl + 'LEIS663' + s,
          top:    loc.baseUrl + 'LEIS666' + s,
          bottom: loc.baseUrl + 'LEIS662' + s,
        };
      }
    }

    function getOrCreateTransitionMesh(mode) {
      if (transitionMesh && transitionMesh.userData.mode !== mode) {
        transitionScene.remove(transitionMesh);
        transitionMesh.geometry.dispose();
        transitionMesh.material.dispose();
        transitionMesh = null;
      }

      if (!transitionMesh) {
        const uniforms = {
          tOld:      { value: null },
          tNew:      { value: null },
          uProgress: { value: 0 },
        };
        if (mode === 'block') {
          uniforms.uBlockSize = { value: 50.0 };
          uniforms.uAspect    = { value: window.innerWidth / window.innerHeight };
        }
        const mat = new THREE.ShaderMaterial({
          uniforms,
          vertexShader:   VERT,
          fragmentShader: mode === 'block' ? FRAG_BLOCK : FRAG_FADE,
          depthTest:   false,
          depthWrite:  false,
          transparent: false
        });
        transitionMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
        transitionMesh.userData.mode = mode;
        transitionScene.add(transitionMesh);
      }

      return transitionMesh;
    }

    function disposeRenderTargets() {
      if (rtOld) { rtOld.dispose(); rtOld = null; }
      if (rtNew) { rtNew.dispose(); rtNew = null; }
    }

    function disposeAll() {
      disposeRenderTargets();
      if (transitionMesh) {
        transitionScene.remove(transitionMesh);
        transitionMesh.geometry.dispose();
        transitionMesh.material.dispose();
        transitionMesh = null;
      }
    }

    // --- UI ---

    function updateUI() {
      const locSelect = document.getElementById('location-selector');
      if (locSelect.options.length === 0) {
        locations.forEach((loc, i) => {
          const opt = document.createElement('option');
          opt.value = i;
          opt.textContent = loc.name;
          locSelect.appendChild(opt);
        });
        locSelect.onchange = (e) => {
          const newLocation = locations[e.target.value];
          const isLocationChange = newLocation !== currentLocation;
          currentLocation = newLocation;
          currentVersionIndex = 0;
          updateUI();
          loadPanorama(isLocationChange ? 'block' : 'fade');
        };
      }

      const activeVersions = getActiveVersions(currentLocation);
      if (currentVersionIndex >= activeVersions.length) currentVersionIndex = 0;

      const qBar = document.getElementById('quality-buttons');
      qBar.innerHTML = '';
      activeVersions.forEach((v, idx) => {
        const btn = document.createElement('button');
        btn.textContent = v.label;
        if (idx === currentVersionIndex) btn.classList.add('active');
        btn.onclick = () => {
          if (currentVersionIndex !== idx && !isTransitioning) {
            currentVersionIndex = idx;
            updateUI();
            loadPanorama('fade');
          }
        };
        qBar.appendChild(btn);
      });
    }

    // --- Panorama loader ---

    async function loadPanorama(mode = 'block') {
      if (isTransitioning) return;
      isTransitioning = true;

      // Ensure any active camera animations are halted before transitioning
      if (typeof viewer.stopAnimation === 'function') {
        viewer.stopAnimation();
      }

      if (currentLocation.audio) {
        playOrCrossfadeAudio(currentLocation.audio);
      }

      const r   = viewer.renderer.renderer;
      const sc  = viewer.renderer.scene;
      const cam = viewer.renderer.camera;
      
      const size = r.getDrawingBufferSize(new THREE.Vector2());

      rtOld = new THREE.WebGLRenderTarget(size.x, size.y);
      r.setRenderTarget(rtOld);
      r.render(sc, cam);
      r.setRenderTarget(null);

      const mesh = getOrCreateTransitionMesh(mode);
      mesh.material.uniforms.tOld.value = rtOld.texture;
      mesh.material.uniforms.tNew.value = null;
      mesh.material.uniforms.uProgress.value = 0;

      if (mode === 'block') {
        mesh.material.uniforms.uAspect.value = size.x / size.y;
      }

      const activeVersions = getActiveVersions(currentLocation);
      const config = getCubemap(currentLocation, activeVersions[currentVersionIndex]);

      try {
        await viewer.setPanorama(config, { transition: false, showLoader: false });
        applyPixelFiltering();

        rtNew = new THREE.WebGLRenderTarget(size.x, size.y);
        r.setRenderTarget(rtNew);
        r.render(sc, cam);
        r.setRenderTarget(null);
        mesh.material.uniforms.tNew.value = rtNew.texture;

        const duration  = mode === 'block' ? 1200 : 600;
        const startTime = performance.now();

        (function animateTransition(now) {
          if (!isTransitioning) return; 

          const p = Math.min((now - startTime) / duration, 1);
          mesh.material.uniforms.uProgress.value = p;

          r.setRenderTarget(null);
          r.clear();
          r.render(sc, cam);
          r.autoClear = false;
          r.render(transitionScene, transitionCamera);
          r.autoClear = true;

          if (p < 1) {
            requestAnimationFrame(animateTransition);
          } else {
            disposeRenderTargets();
            isTransitioning = false;
            applyPixelFiltering();
          }
        })(performance.now());

      } catch (err) {
        console.error('Transition failed:', err);
        disposeRenderTargets();
        isTransitioning = false;
      }
    }

    function applyPixelFiltering() {
      if (!viewer.renderer?.mesh) return;
      const materials = viewer.renderer.mesh.material;
      (Array.isArray(materials) ? materials : [materials]).forEach(mat => {
        if (mat.map) {
          mat.map.magFilter = THREE.NearestFilter;
          mat.map.minFilter = THREE.LinearMipmapLinearFilter;
          mat.map.needsUpdate = true;
        }
      });
    }

    // --- Gyro pitch settle ---

    function readDevicePitchOnce(timeoutMs = 700) {
      return new Promise((resolve) => {
        let done = false;
        function finish(val) {
          if (done) return;
          done = true;
          window.removeEventListener('deviceorientation', onOri, true);
          resolve(val);
        }
        function onOri(e) {
          if (typeof e.beta !== 'number') return;
          const pitchRad = THREE.MathUtils.degToRad(
            THREE.MathUtils.clamp(e.beta, -85, 85)
          );
          finish(-pitchRad);
        }
        window.addEventListener('deviceorientation', onOri, true);
        setTimeout(() => finish(null), timeoutMs);
      });
    }

    async function settlePitchToDevice() {
      const { yaw } = viewer.getPosition();
      const targetPitch = await readDevicePitchOnce();
      if (targetPitch == null) return;
      viewer.animate({ yaw, pitch: targetPitch, speed: 700 });
    }

    // --- Viewer ---

    const viewer = new Viewer({
      container: 'viewer',
      adapter: CubemapAdapter,
      
      // Prevent Gimbal Lock by restricting absolute up/down look angles
      minPitch: -(Math.PI / 2) + 0.01,
      maxPitch: (Math.PI / 2) - 0.01,

      plugins: [
        [GyroscopePlugin, {
          moveMode: 'fast',
          absolutePosition: false, 
          roll: false              
        }]
      ],
      panorama: getCubemap(locations[0], locations[0].versions[0]),
      caption: '',
      loadingImg: 'https://photo-sphere-viewer-data.netlify.app/assets/loader.gif',
      touchmoveTwoFingers: false,
      mousewheelCtrlKey: false,
      minFov: 10,
      maxFov: 110,
      navbar: ['zoom', 'move', 'download', 'gyroscope', 'fullscreen']
    });

    updateUI();
    
    // Initialize audio system with first location on load
    if (currentLocation.audio) {
      audioSystem.currentUrl = currentLocation.audio;
    }

    viewer.addEventListener('panorama-loaded', applyPixelFiltering);

    viewer.addEventListener('render', () => {
      if (!isTransitioning || !transitionMesh) return;
      const renderer = viewer.renderer.renderer;
      const prev = renderer.autoClear;
      renderer.autoClear = false;
      renderer.render(transitionScene, transitionCamera);
      renderer.autoClear = prev;
    });

    viewer.addEventListener('ready', () => {
      const gyro = viewer.getPlugin(GyroscopePlugin);
      if (!gyro) return;
      gyro.addEventListener('gyroscope-enabled', settlePitchToDevice);
    });

    window.addEventListener('resize', () => {
      disposeAll();
      isTransitioning = false;
      document.body.style.height = window.innerHeight + 'px';
    });

  </script>
</body>
</html>
