<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Cubemap VR (Parallax Depth)</title>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Cubemap VR">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#000000">

  <style>
    body, html {
      margin: 0; padding: 0;
      width: 100%; height: 100vh; height: 100dvh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #000;
    }
    #viewer-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
    
    .ui-container {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: 50%;
      transform: translateX(-50%);
      display: flex; flex-direction: column;
      align-items: center; gap: 8px;
      z-index: 10000; 
      width: 96%;
      pointer-events: none;
    }
    
    .controls-row {
      display: flex; gap: 6px; align-items: center; justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 6px; padding: 6px 10px;
      pointer-events: auto; white-space: nowrap;
      max-width: 100%; overflow-x: auto;
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .controls-row::-webkit-scrollbar { display: none; }
    .controls-row { -ms-overflow-style: none; scrollbar-width: none; }
    
    button, select {
      background: transparent; 
      color: rgba(255, 255, 255, 0.9);
      border: none; border-radius: 4px;
      font-size: 13px; font-weight: 500;
      padding: 6px 12px; cursor: pointer;
      outline: none; transition: background 0.2s, color 0.2s;
    }
    button:hover, select:hover { background: rgba(255, 255, 255, 0.15); color: #fff; }
    button.active { background: rgba(255, 255, 255, 0.25); color: #fff; }
    
    select {
      appearance: none; padding-right: 28px;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22rgba(255,255,255,0.8)%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat; background-position: right 8px top 50%; background-size: 10px auto;
    }

    input[type=range] { -webkit-appearance: none; background: transparent; width: 100px; margin: 0 4px; transition: opacity 0.2s; flex-shrink: 0; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 3px; background: rgba(255,255,255,0.3); border-radius: 1.5px; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: rgba(255,255,255,0.9); margin-top: -6.5px; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.5); }
    input[type=range]::-webkit-slider-thumb:hover { background: #fff; transform: scale(1.15); transition: transform 0.1s ease; }
    
    .depth-label { color:rgba(255,255,255,0.8); font-size:11px; text-transform:uppercase; margin-left: 8px; font-weight: bold; letter-spacing: 0.5px; }
    .depth-label:first-child { margin-left: 0; }

    #caption {
      position: absolute; left: 50%; transform: translateX(-50%);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 54px);
      z-index: 100; background: rgba(0,0,0,0.7); color: #fff;
      padding: 10px 24px 10px 20px; border-radius: 8px; font-size: 13px; font-weight: 500;
      max-width: 85vw; text-align: center; line-height: 1.4; pointer-events: auto;
    }
    #close-caption { position: absolute; top: 4px; right: 8px; font-size: 18px; font-weight: bold; opacity: 0.6; cursor: pointer; line-height: 1; transition: opacity 0.2s; }
    #close-caption:hover { opacity: 1; }

    /* Overlays & Toggles */
    #dni-trigger { width: 20px; height: 20px; margin-left: 6px; cursor: pointer; border-radius: 4px; transition: background 0.2s; padding: 2px; }
    #dni-trigger:hover { background: rgba(255,255,255,0.1); }
    #dni-zoom-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 9999;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      opacity: 0; pointer-events: none; transition: opacity 0.3s ease; backdrop-filter: blur(8px);
    }
    #dni-zoom-overlay.active { opacity: 1; pointer-events: auto; }
    #close-overlay { position: absolute; top: 20px; right: 20px; color: rgba(255,255,255,0.6); font-size: 40px; font-weight: 300; cursor: pointer; line-height: 1; transition: color 0.2s; padding: 10px; }
    #close-overlay:hover { color: #fff; }
    #large-volume-slider { width: 50vmin; max-width: 400px; margin-top: 40px; }
    #large-volume-slider::-webkit-slider-thumb { height: 20px; width: 20px; margin-top: -9px; }
    
    #video-toggle, #gyro-toggle { display: none; padding: 6px 10px; }
    #gyro-toggle { display: inline-flex; align-items: center; justify-content: center; }
    #video-toggle { font-size: 14px; }
    
    #loader {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1001;
      width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1); border-top-color: #fff; border-radius: 50%;
      animation: spin 1s linear infinite; pointer-events: none; display: none;
    }
    @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>

  <video id="source-video" crossOrigin="anonymous" loop playsInline muted style="display:none;"></video>

  <div id="viewer-container"></div>
  <div id="loader"></div>

  <div class="ui-container">
    <div class="controls-row">
      <label style="color:rgba(255,255,255,0.8);font-size:11px;align-self:center;text-transform:uppercase;margin:0 4px;">Location</label>
      <select id="location-selector"></select>
      <div style="width:1px; height:16px; background:rgba(255,255,255,0.2); margin: 0 4px;"></div>
      <div id="quality-buttons" style="display:flex; gap:2px;"></div>
    </div>
    
    <div class="controls-row">
      <button id="video-toggle" title="Play/Pause Video">▶</button>
      <button id="gyro-toggle" title="Toggle Gyroscope">
        <svg viewBox="0 0 24 24" style="width:18px; height:18px; stroke:currentColor; fill:none; stroke-width:2; vertical-align:middle;">
          <circle cx="12" cy="12" r="8"></circle>
          <ellipse cx="12" cy="12" rx="8" ry="3" transform="rotate(45 12 12)"></ellipse>
          <ellipse cx="12" cy="12" rx="8" ry="3" transform="rotate(-45 12 12)"></ellipse>
        </svg>
      </button>
      <button id="audio-toggle" style="font-size: 16px;">♫</button>
      <input type="range" id="volume-slider" min="0" max="25" value="0">
      <div id="dni-trigger" title="View large symbol">
        <svg viewBox="-15 -15 30 30" style="width:100%; height:100%; stroke: rgba(255,255,255,0.8); fill: none; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
          <path d="M -12,-10 H 12 M -12,10 H 12 M -10,-10 V 10 M 10,-10 V 10" />
          <path id="dni-line-0" d="M 0,0 Q 0,0 0,0" />
          <path id="dni-line-1" d="M 0,0 Q 0,0 0,0" />
          <path id="dni-line-2" d="M 0,0 Q 0,0 0,0" />
          <path id="dni-line-3" d="M 0,0 Q 0,0 0,0" />
        </svg>
      </div>
    </div>

    <div class="controls-row" id="depth-controls" style="display:none; padding-left: 14px; padding-right: 14px;">
      <label class="depth-label">3D Parallax</label>
      <input type="range" id="displacement-slider" min="-100" max="100" value="0" title="Mesh Deformation Strength">
    </div>
  </div>

  <div id="dni-zoom-overlay">
    <div id="close-overlay" title="Close">&times;</div>
    <svg viewBox="-15 -15 30 30" style="width: 50vmin; height: 50vmin; max-width: 400px; max-height: 400px; stroke: #fff; fill: none; stroke-width: 0.6; stroke-linecap: round; stroke-linejoin: round;">
      <path d="M -12,-10 H 12 M -12,10 H 12 M -10,-10 V 10 M 10,-10 V 10" />
      <path id="dni-large-0" d="M 0,0 Q 0,0 0,0" />
      <path id="dni-large-1" d="M 0,0 Q 0,0 0,0" />
      <path id="dni-large-2" d="M 0,0 Q 0,0 0,0" />
      <path id="dni-large-3" d="M 0,0 Q 0,0 0,0" />
    </svg>
    <input type="range" id="large-volume-slider" min="0" max="25" value="0">
  </div>

  <div id="caption">
    <div id="close-caption" title="Hide caption">&times;</div>
    This product was created using artwork with ™ and/or © works of Cyan. All rights reserved by Cyan.<br>
    <span style="font-size: 0.9em; opacity: 0.8;">
      D'ni numerals © 2026 by Robin Lionheart, used under CC BY-NC-ND 2.5.
    </span>
  </div>

  <script type="module">
    import * as THREE from 'three';

    const rawUrl = 'https://raw.githubusercontent.com/e-z-g/e-z-g.github.io/main/';

    const locations = [
      {
        name: 'Amateria',
        baseUrl: rawUrl + 'vr2/',
        type: 'side-numbered',
        audio: rawUrl + 'cubemapvr/audio_amateria.mp3',
        hasDepth: false,
        versions: [
          { label: 'Original', suffix: '_orig.jpeg' },
          { label: '4K',       suffix: '_seamless.webp' }
        ]
      },
      {
        name: 'Voltaic',
        baseUrl: rawUrl + 'vr2/',
        type: 'voltaic',
        audio: rawUrl + 'cubemapvr/audio_amateria.mp3',
        hasDepth: true,
        depthSuffix: '-depth.jpeg', 
        versions: [
          { label: 'Original', suffix: '_orig.jpeg' },
          { label: 'Alt (IMG)', type: 'img-seq' },
          { label: 'Video (5x3)', type: 'video-5x3', url: rawUrl + 'cubemapvr/voltaic_video.mp4' }
        ]
      },
      {
        name: 'J\'nanin',
        baseUrl: rawUrl + 'cubemapvr/',
        type: 'classic-leis',
        audio: rawUrl + 'cubemapvr/audio_jnanin.mp3',
        hasDepth: false,
        versions: [
          { label: 'Original',    suffix: '-orig.jpg' },
          { label: '2K (HD)',     suffix: '-hdmod.webp' },
          { label: '6K',          suffix: '-seamless.webp' }
        ]
      }
    ];
    
    let currentLocation = locations[1];
    let currentVersionIndex = 0;
    
    // --- Audio System ---
    // Added fadeInterval to prevent interval memory leaks
    const audioSystem = { active: new Audio(), fading: new Audio(), isMuted: true, masterVolume: 0, currentUrl: currentLocation.audio, fadeInterval: null };
    audioSystem.active.loop = true; audioSystem.fading.loop = true;

    const audioToggleBtn = document.getElementById('audio-toggle');
    const volumeSlider = document.getElementById('volume-slider');
    const largeVolumeSlider = document.getElementById('large-volume-slider');
    let savedVolume = 15; 

    function setVolume(rawVal) {
      const val = parseInt(rawVal, 10);
      audioSystem.masterVolume = val / 25;
      volumeSlider.value = val; largeVolumeSlider.value = val;

      if (val === 0) {
        audioSystem.isMuted = true; audioToggleBtn.classList.remove('active'); audioSystem.active.pause();
      } else {
        audioSystem.isMuted = false; audioToggleBtn.classList.add('active');
        if (audioSystem.currentUrl && (!audioSystem.active.src || audioSystem.active.src === '')) playOrCrossfadeAudio(audioSystem.currentUrl);
        else if (audioSystem.active.paused) audioSystem.active.play().catch(e => console.warn(e));
        audioSystem.active.volume = audioSystem.masterVolume;
      }
      targetDniState = dniStates[val];
      if (!isDniAnimating) { isDniAnimating = true; animateDni(); }
    }

    audioToggleBtn.addEventListener('click', () => { setVolume(audioSystem.masterVolume === 0 ? savedVolume : (savedVolume = Math.round(audioSystem.masterVolume * 25), 0)); });
    volumeSlider.addEventListener('input', (e) => setVolume(e.target.value));
    largeVolumeSlider.addEventListener('input', (e) => setVolume(e.target.value));

    function playOrCrossfadeAudio(newUrl) {
      if (!newUrl) return;
      if (audioSystem.currentUrl === newUrl && audioSystem.active.src) {
        if (!audioSystem.isMuted && audioSystem.masterVolume > 0 && audioSystem.active.paused) audioSystem.active.play().catch(e=>console.warn(e));
        return;
      }
      audioSystem.currentUrl = newUrl;
      if (audioSystem.isMuted || audioSystem.masterVolume === 0) return;

      const temp = audioSystem.fading; audioSystem.fading = audioSystem.active; audioSystem.active = temp;
      audioSystem.active.src = newUrl; audioSystem.active.volume = 0;
      audioSystem.active.play().catch(e => console.warn(e));

      // Clear any existing intervals to prevent overlapping crossfades
      if (audioSystem.fadeInterval) clearInterval(audioSystem.fadeInterval);

      let step = 0; const steps = 20;
      audioSystem.fadeInterval = setInterval(() => {
        step++; const progress = step / steps;
        audioSystem.active.volume = progress * audioSystem.masterVolume;
        if (audioSystem.fading.src) audioSystem.fading.volume = Math.max(0, 1 - progress) * audioSystem.masterVolume;
        if (step >= steps) { 
            clearInterval(audioSystem.fadeInterval); 
            if (audioSystem.fading.src) { 
                audioSystem.fading.pause(); 
                audioSystem.fading.removeAttribute('src'); 
            } 
        }
      }, 50);
    }

    // --- D'ni SVG Morph Engine ---
    const emptyPath = [0,0, 0,0, 0,0];
    const onesMap = { 0: [emptyPath, emptyPath], 1: [[0,-10, 0,-5, 0,0], [0,0, 0,5, 0,10]], 2: [[-10,-10, -5,-5, -5,0], [-5,0, -5,5, -10,10]], 3: [[0,-10, -5,-5, -10,0], [-10,0, -5,5, 0,10]], 4: [[0,10, 0,2.5, 0,-5], [0,-5, 5,-5, 10,-5]] };
    const fivesMap = { 0: [emptyPath, emptyPath], 1: [[-10,0, -5,0, 0,0], [0,0, 5,0, 10,0]], 2: [[-10,10, -5,5, 0,5], [0,5, 5,5, 10,10]], 3: [[-10,0, -5,5, 0,10], [0,10, 5,5, 10,0]], 4: [[10,0, 2.5,0, -5,0], [-5,0, -5,-5, -5,-10]] };
    const dniStates = [];
    for (let i = 0; i <= 25; i++) {
      if (i === 0) dniStates.push([ [-0.75,0, 0,-1, 0.75,0], [0.75,0, 0,1, -0.75,0], emptyPath, emptyPath ]); 
      else if (i === 25) dniStates.push([ [-10,10, -5,5, 0,0], [0,0, 5,-5, 10,-10], [-10,-10, -5,-5, 0,0], [0,0, 5,5, 10,10] ]);
      else dniStates.push([ ...onesMap[i % 5], ...fivesMap[Math.floor(i / 5)] ]);
    }
    let currentDniState = JSON.parse(JSON.stringify(dniStates[0]));
    let targetDniState = dniStates[0]; let isDniAnimating = false;
    const dniPaths = [0,1,2,3].map(i => document.getElementById(`dni-line-${i}`));
    const dniLargePaths = [0,1,2,3].map(i => document.getElementById(`dni-large-${i}`));
    
    function animateDni() {
      let needsUpdate = false;
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 6; j++) {
          const diff = targetDniState[i][j] - currentDniState[i][j];
          if (Math.abs(diff) > 0.05) { currentDniState[i][j] += diff * 0.15; needsUpdate = true; } 
          else currentDniState[i][j] = targetDniState[i][j];
        }
        const s = currentDniState[i]; const str = `M ${s[0]},${s[1]} Q ${s[2]},${s[3]} ${s[4]},${s[5]}`;
        dniPaths[i].setAttribute('d', str); dniLargePaths[i].setAttribute('d', str);
      }
      if (needsUpdate) requestAnimationFrame(animateDni); else isDniAnimating = false;
    }

    const overlay = document.getElementById('dni-zoom-overlay');
    document.getElementById('dni-trigger').addEventListener('click', () => { overlay.classList.add('active'); volumeSlider.style.opacity = '0'; volumeSlider.style.pointerEvents = 'none'; });
    const closeOverlay = () => { overlay.classList.remove('active'); volumeSlider.style.opacity = '1'; volumeSlider.style.pointerEvents = 'auto'; };
    document.getElementById('close-overlay').addEventListener('click', closeOverlay);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) closeOverlay(); });
    document.getElementById('close-caption').addEventListener('click', () => document.getElementById('caption').style.display = 'none');

    const sourceVideo = document.getElementById('source-video');
    const videoToggleBtn = document.getElementById('video-toggle');
    let isVideoPlaying = false;
    sourceVideo.addEventListener('play', () => { isVideoPlaying = true; videoToggleBtn.textContent = '⏸'; });
    sourceVideo.addEventListener('pause', () => { isVideoPlaying = false; videoToggleBtn.textContent = '▶'; });
    videoToggleBtn.addEventListener('click', () => sourceVideo.paused ? sourceVideo.play() : sourceVideo.pause());

    // --- Pure Three.js Core Engine ---
    const container = document.getElementById('viewer-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 500); 
    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Highly Subdivided Cube Mesh (64x64 is reliable for smooth depth rendering)
    const geometry = new THREE.BoxGeometry(100, 100, 100, 64, 64, 64);
    geometry.scale(-1, 1, 1); 
    
    // --- Custom Depth Shader Materials ---
    const dummyDepthData = new Uint8Array([0, 0, 0, 255]); 
    const dummyDepthTex = new THREE.DataTexture(dummyDepthData, 1, 1, THREE.RGBAFormat);
    dummyDepthTex.minFilter = THREE.NearestFilter;
    dummyDepthTex.magFilter = THREE.NearestFilter;
    dummyDepthTex.generateMipmaps = false;
    dummyDepthTex.needsUpdate = true;

    const depthShaderDef = {
      vertexShader: `
        uniform sampler2D tDepth;
        uniform float uDisplacementScale;
        varying vec2 vUv;

        void main() {
          vUv = uv;
          vec4 dTex = texture2D(tDepth, uv);
          float vDepth = clamp(dTex.r, 0.0, 1.0);

          // We push vertices directly towards the center origin based on depth intensity.
          vec3 dir = -normalize(position);
          vec3 newPos = position + dir * (vDepth * uDisplacementScale);
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tColor;
        varying vec2 vUv;

        void main() {
          gl_FragColor = texture2D(tColor, vUv);
        }
      `
    };

    // Instantiate explicitly for each face to ensure uniforms are independent & textures bind safely
    const materials = [];
    for (let i = 0; i < 6; i++) {
      materials.push(new THREE.ShaderMaterial({
        uniforms: {
          tColor: { value: null },
          tDepth: { value: dummyDepthTex },
          uDisplacementScale: { value: 0.0 } 
        },
        vertexShader: depthShaderDef.vertexShader,
        fragmentShader: depthShaderDef.fragmentShader,
        side: THREE.FrontSide,
        depthWrite: true 
      }));
    }

    const cubeMesh = new THREE.Mesh(geometry, materials);
    scene.add(cubeMesh);

    // --- Depth Controls UI Mapping ---
    const depthControlsContainer = document.getElementById('depth-controls');
    document.getElementById('displacement-slider').addEventListener('input', (e) => {
      const val = parseFloat(e.target.value) / 100.0;
      materials.forEach(m => m.uniforms.uDisplacementScale.value = val * 20.0); 
    });

    // --- Video GPU Shader Setup ---
    const videoTexture = new THREE.VideoTexture(sourceVideo);
    videoTexture.colorSpace = THREE.SRGBColorSpace;
    videoTexture.minFilter = THREE.LinearFilter;
    videoTexture.magFilter = THREE.LinearFilter;
    videoTexture.generateMipmaps = false;

    const videoMaterials = [];
    for (let i = 0; i < 6; i++) {
      videoMaterials.push(new THREE.ShaderMaterial({
        uniforms: { tVideo: { value: videoTexture }, uFace: { value: i } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
          uniform sampler2D tVideo; uniform int uFace; varying vec2 vUv;
          vec2 getGrid(float col, float row, vec2 localUv) { return vec2((col + localUv.x) / 5.0, (2.0 - row + localUv.y) / 3.0); }
          vec2 rotateUV(vec2 uv, float angleDeg) {
            float a = radians(angleDeg); float s = sin(a), c = cos(a);
            vec2 p = uv - 0.5; return vec2(p.x * c - p.y * s, p.x * s + p.y * c) + 0.5;
          }
          void main() {
            vec2 local = vUv; vec4 color = vec4(0.0);
            if (uFace == 0) { 
              vec4 c4 = texture2D(tVideo, getGrid(4.0, 1.0, local)); vec4 c0 = texture2D(tVideo, getGrid(0.0, 1.0, local));
              color = mix(c4, c0, smoothstep(0.25, 0.75, local.x));
            } else if (uFace == 1) { color = texture2D(tVideo, getGrid(2.0, 1.0, local));
            } else if (uFace == 2) { 
              if (local.y > local.x && local.y > 1.0 - local.x) color = texture2D(tVideo, getGrid(3.0, 0.0, rotateUV(local, 180.0)));
              else if (local.x < local.y && local.x < 1.0 - local.y) color = texture2D(tVideo, getGrid(0.0, 0.0, rotateUV(local, 90.0)));
              else if (local.x > local.y && local.x > 1.0 - local.y) color = texture2D(tVideo, getGrid(2.0, 0.0, rotateUV(local, -90.0)));
              else color = texture2D(tVideo, getGrid(1.0, 0.0, local));
            } else if (uFace == 3) { 
              if (local.y < local.x && local.y < 1.0 - local.x) color = texture2D(tVideo, getGrid(3.0, 2.0, rotateUV(local, 180.0)));
              else if (local.x < local.y && local.x < 1.0 - local.y) color = texture2D(tVideo, getGrid(0.0, 2.0, rotateUV(local, -90.0)));
              else if (local.x > local.y && local.x > 1.0 - local.y) color = texture2D(tVideo, getGrid(2.0, 2.0, rotateUV(local, 90.0)));
              else color = texture2D(tVideo, getGrid(1.0, 2.0, local));
            } else if (uFace == 4) { color = texture2D(tVideo, getGrid(3.0, 1.0, local));
            } else if (uFace == 5) { color = texture2D(tVideo, getGrid(1.0, 1.0, local)); }
            gl_FragColor = color;
          }
        `,
        depthWrite: false, side: THREE.FrontSide
      }));
    }

    // --- Custom Camera Controller ---
    let lon = 225, lat = 0; 
    let phi = 0, theta = 0;
    let isDragging = false, startX, startY, startLon, startLat;
    let useGyro = false, gyroEnabled = false;
    const gyroEuler = new THREE.Euler(), gyroQ0 = new THREE.Quaternion(), gyroQ1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), zee = new THREE.Vector3(0, 0, 1);
    let deviceOrientation = null, screenOrientation = 0;

    window.addEventListener('orientationchange', () => { screenOrientation = (screen.orientation || {}).angle || window.orientation || 0; });
    document.getElementById('gyro-toggle').addEventListener('click', () => {
      if (!gyroEnabled) {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission().then(state => {
            if (state === 'granted') { window.addEventListener('deviceorientation', (e) => deviceOrientation = e); gyroEnabled = true; useGyro = true; document.getElementById('gyro-toggle').classList.add('active'); }
          }).catch(console.error);
        } else { window.addEventListener('deviceorientation', (e) => deviceOrientation = e); gyroEnabled = true; useGyro = true; document.getElementById('gyro-toggle').classList.add('active'); }
      } else {
        useGyro = !useGyro; document.getElementById('gyro-toggle').classList.toggle('active', useGyro);
        if (!useGyro) {
           const vector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
           lat = 90 - THREE.MathUtils.radToDeg(Math.acos(vector.y)); lon = THREE.MathUtils.radToDeg(Math.atan2(vector.x, vector.z));
        }
      }
    });

    const onPointerDown = (clientX, clientY) => { isDragging = true; useGyro = false; startX = clientX; startY = clientY; startLon = lon; startLat = lat; };
    const onPointerMove = (clientX, clientY, isTouch = false) => {
      if (!isDragging) return;
      const sensitivity = isTouch ? 0.35 : 0.15; // Increased touch swiping speed
      lon = startLon - (clientX - startX) * sensitivity; 
      lat = startLat + (clientY - startY) * sensitivity; 
      lat = Math.max(-85, Math.min(85, lat)); 
    };

    renderer.domElement.addEventListener('mousedown', e => onPointerDown(e.clientX, e.clientY));
    document.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY, false));
    document.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; if (gyroEnabled) useGyro = true; } });
    
    // Zoom Logic
    let initialPinchDistance = null, initialFov = camera.fov;
    const getPinchDistance = (e) => Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);

    renderer.domElement.addEventListener('wheel', (e) => {
      camera.fov += e.deltaY * 0.05; camera.fov = Math.max(30, Math.min(120, camera.fov)); camera.updateProjectionMatrix();
    }, { passive: true });

    renderer.domElement.addEventListener('touchstart', e => {
      if (e.touches.length === 1) onPointerDown(e.touches[0].clientX, e.touches[0].clientY);
      else if (e.touches.length === 2) { isDragging = false; initialPinchDistance = getPinchDistance(e); initialFov = camera.fov; }
    }, {passive: false});

    document.addEventListener('touchmove', e => {
      if (e.touches.length === 1 && isDragging) { e.preventDefault(); onPointerMove(e.touches[0].clientX, e.touches[0].clientY, true); } 
      else if (e.touches.length === 2 && initialPinchDistance !== null) {
        e.preventDefault(); const scale = initialPinchDistance / getPinchDistance(e);
        camera.fov = initialFov * scale; camera.fov = Math.max(30, Math.min(120, camera.fov)); camera.updateProjectionMatrix();
      }
    }, {passive: false});
    document.addEventListener('touchend', e => {
      if (e.touches.length === 0) { if (isDragging) { isDragging = false; if (gyroEnabled) useGyro = true; } initialPinchDistance = null; } 
      else if (e.touches.length === 1) { initialPinchDistance = null; onPointerDown(e.touches[0].clientX, e.touches[0].clientY); }
    });

    // --- Fullscreen Transition Logic ---
    const transitionScene = new THREE.Scene(); const transitionCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    let rtOld = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { colorSpace: THREE.SRGBColorSpace });
    let rtNew = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { colorSpace: THREE.SRGBColorSpace });
    const FRAG_BLOCK = `uniform sampler2D tOld; uniform sampler2D tNew; uniform float uProgress; uniform float uAspect; varying vec2 vUv; float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); } void main() { vec2 correctedUv = vec2(vUv.x * uAspect, vUv.y); vec2 blockUv = floor(correctedUv * 50.0) / 50.0; if (uProgress * 1.2 > (1.0 - vUv.y) + hash(blockUv) * 0.2) { gl_FragColor = texture2D(tNew, vUv); } else { gl_FragColor = texture2D(tOld, vUv); } }`;
    const FRAG_FADE = `uniform sampler2D tOld; uniform sampler2D tNew; uniform float uProgress; varying vec2 vUv; void main() { gl_FragColor = mix(texture2D(tOld, vUv), texture2D(tNew, vUv), smoothstep(0.0, 1.0, uProgress)); }`;
    const transitionMat = new THREE.ShaderMaterial({ uniforms: { tOld: { value: null }, tNew: { value: null }, uProgress: { value: 0 }, uAspect: { value: 1.0 } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`, fragmentShader: FRAG_BLOCK, depthTest: false, depthWrite: false });
    transitionScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), transitionMat));

    let isTransitioning = false;
    const textureLoader = new THREE.TextureLoader(); textureLoader.crossOrigin = 'anonymous';

    function getCubemapUrls(loc, version, fetchDepth = false) {
      const s = fetchDepth ? loc.depthSuffix : (typeof version === 'string' ? version : (version.suffix || ''));
      const type = (typeof version === 'object' && version.type) ? version.type : loc.type;
      
      let p;
      if (type === 'img-seq') { 
          const b = rawUrl + 'cubemapvr/'; 
          // Left and Right faces swapped as requested for this variation
          p = { front: b+'IMG_5228.jpeg', bottom: b+'IMG_5229.jpeg', back: b+'IMG_5230.jpeg', left: b+'IMG_5232.jpeg', right: b+'IMG_5231.jpeg', top: b+'IMG_5233.jpeg' }; 
      } 
      else if (type === 'side-numbered') { p = { front: loc.baseUrl+'MAWWnodes-8'+s, bottom: loc.baseUrl+'MAWWnodes-9'+s, back: loc.baseUrl+'MAWWnodes-10'+s, right: loc.baseUrl+'MAWWnodes-11'+s, left: loc.baseUrl+'MAWWnodes-12'+s, top: loc.baseUrl+'MAWWnodes-13'+s }; } 
      else if (type === 'voltaic') { 
        p = { left: loc.baseUrl+'ENCHnodes-281'+s, front: loc.baseUrl+'ENCHnodes-277'+s, right: loc.baseUrl+'ENCHnodes-280'+s, back: loc.baseUrl+'ENCHnodes-279'+s, top: loc.baseUrl+'ENCHnodes-282'+s, bottom: loc.baseUrl+'ENCHnodes-278'+s }; 
      } 
      else { p = { left: loc.baseUrl+'LEIS665'+s, front: loc.baseUrl+'LEIS661'+s, right: loc.baseUrl+'LEIS664'+s, back: loc.baseUrl+'LEIS663'+s, top: loc.baseUrl+'LEIS666'+s, bottom: loc.baseUrl+'LEIS662'+s }; }
      
      return [p.left, p.right, p.top, p.bottom, p.back, p.front]; 
    }

    async function loadPanorama(mode = 'block') {
      if (isTransitioning) return;
      isTransitioning = true;
      document.getElementById('loader').style.display = 'block';
      if (currentLocation.audio) playOrCrossfadeAudio(currentLocation.audio);

      renderer.setRenderTarget(rtOld); renderer.render(scene, camera); renderer.setRenderTarget(null);
      transitionMat.uniforms.tOld.value = rtOld.texture; transitionMat.uniforms.uProgress.value = 0;
      transitionMat.fragmentShader = mode === 'block' ? FRAG_BLOCK : FRAG_FADE; transitionMat.needsUpdate = true;

      const targetVersion = currentLocation.versions[currentVersionIndex];
      const isVideo = targetVersion.type === 'video-5x3';
      
      if (isVideo) {
        depthControlsContainer.style.display = 'none';
        videoToggleBtn.style.display = 'inline-block';
        sourceVideo.src = targetVersion.url; sourceVideo.load();
        await new Promise(r => { sourceVideo.onloadeddata = () => r(); });
        cubeMesh.material = videoMaterials; 
      } else {
        videoToggleBtn.style.display = 'none';
        sourceVideo.pause();
        cubeMesh.material = materials; 
        
        // 1. Fetch RGB Textures
        const urls = getCubemapUrls(currentLocation, targetVersion, false);
        const textures = await Promise.all(urls.map(url => textureLoader.loadAsync(url)));
        
        // 2. Fetch Depth Textures safely
        let depthTextures = null;
        if (currentLocation.hasDepth) {
            depthControlsContainer.style.display = 'flex';
            const dUrls = getCubemapUrls(currentLocation, targetVersion, true);
            depthTextures = await Promise.all(dUrls.map(async (url) => {
                try {
                    return await textureLoader.loadAsync(url);
                } catch(e) {
                    console.warn("Missing depth map:", url);
                    return dummyDepthTex;
                }
            }));
        } else {
            depthControlsContainer.style.display = 'none';
        }

        const currentSliderVal = currentLocation.hasDepth ? (parseFloat(document.getElementById('displacement-slider').value) / 100.0) : 0.0;
        
        // 3. Apply Uniforms & Textures
        materials.forEach((mat, i) => {
          if (mat.uniforms.tColor.value) mat.uniforms.tColor.value.dispose();
          mat.uniforms.tColor.value = textures[i];
          mat.uniforms.tColor.value.colorSpace = THREE.SRGBColorSpace;
          mat.uniforms.tColor.value.minFilter = THREE.LinearMipmapLinearFilter;
          mat.uniforms.tColor.value.magFilter = THREE.LinearFilter;
          mat.uniforms.tColor.value.generateMipmaps = true;
          
          if (depthTextures && depthTextures[i] && depthTextures[i] !== dummyDepthTex) {
              if (mat.uniforms.tDepth.value && mat.uniforms.tDepth.value !== dummyDepthTex) mat.uniforms.tDepth.value.dispose();
              mat.uniforms.tDepth.value = depthTextures[i];
              
              mat.uniforms.tDepth.value.colorSpace = THREE.NoColorSpace;
              mat.uniforms.tDepth.value.minFilter = THREE.LinearFilter;
              mat.uniforms.tDepth.value.magFilter = THREE.LinearFilter;
              mat.uniforms.tDepth.value.generateMipmaps = false;
          } else {
              mat.uniforms.tDepth.value = dummyDepthTex; 
          }
          
          mat.uniforms.uDisplacementScale.value = currentSliderVal * 20.0;
          mat.needsUpdate = true;
        });
      }

      renderer.setRenderTarget(rtNew); renderer.render(scene, camera); renderer.setRenderTarget(null);
      transitionMat.uniforms.tNew.value = rtNew.texture;
      document.getElementById('loader').style.display = 'none';

      const duration = mode === 'block' ? 1200 : 600; const startTime = performance.now();
      function animateTween(now) {
        const p = Math.min((now - startTime) / duration, 1); transitionMat.uniforms.uProgress.value = p;
        if (p < 1) requestAnimationFrame(animateTween); else isTransitioning = false;
      }
      requestAnimationFrame(animateTween);
    }

    // --- Main Render Loop ---
    function render() {
      requestAnimationFrame(render);

      // FIX: Reset camera position to the origin before recalculating lookAt vectors!
      // This prevents the camera rotation from drifting based on the offset of previous frames.
      camera.position.set(0, 0, 0);

      if (useGyro && deviceOrientation) {
        const alpha = deviceOrientation.alpha ? THREE.MathUtils.degToRad(deviceOrientation.alpha) : 0;
        const beta = deviceOrientation.beta ? THREE.MathUtils.degToRad(deviceOrientation.beta) : 0;
        const gamma = deviceOrientation.gamma ? THREE.MathUtils.degToRad(deviceOrientation.gamma) : 0;
        const orient = screenOrientation ? THREE.MathUtils.degToRad(screenOrientation) : 0;
        gyroEuler.set(beta, alpha, -gamma, 'YXZ');
        camera.quaternion.setFromEuler(gyroEuler).multiply(gyroQ1).multiply(gyroQ0.setFromAxisAngle(zee, -orient));
      } else {
        phi = THREE.MathUtils.degToRad(90 - lat); theta = THREE.MathUtils.degToRad(lon);
        camera.lookAt(new THREE.Vector3(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta)));
      }
      
      // Pivot offset (Neck Model): Restored to generate parallax from depth maps
      // Pushing the camera slightly off-center makes the geometry scale reveal real 3D depth as you rotate
      const neckLength = 2.0;
      camera.position.set(0, 0, neckLength);
      camera.position.applyQuaternion(camera.quaternion);
      camera.position.multiplyScalar(-1); 

      if (isTransitioning) renderer.render(transitionScene, transitionCamera);
      else renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      rtOld.setSize(window.innerWidth, window.innerHeight); rtNew.setSize(window.innerWidth, window.innerHeight);
      transitionMat.uniforms.uAspect.value = window.innerWidth / window.innerHeight;
    });

    function updateUI() {
      const locSelect = document.getElementById('location-selector');
      if (locSelect.options.length === 0) {
        locations.forEach((loc, i) => { const opt = document.createElement('option'); opt.value = i; opt.textContent = loc.name; if (loc === currentLocation) opt.selected = true; locSelect.appendChild(opt); });
        locSelect.onchange = (e) => {
          const isLocChange = locations[e.target.value] !== currentLocation;
          currentLocation = locations[e.target.value]; currentVersionIndex = 0;
          updateUI(); loadPanorama(isLocChange ? 'block' : 'fade');
        };
      }
      const qBar = document.getElementById('quality-buttons'); qBar.innerHTML = '';
      currentLocation.versions.forEach((v, idx) => {
        const btn = document.createElement('button'); btn.textContent = v.label;
        if (idx === currentVersionIndex) btn.classList.add('active');
        btn.onclick = () => { if (currentVersionIndex !== idx && !isTransitioning) { currentVersionIndex = idx; updateUI(); loadPanorama('fade'); } };
        qBar.appendChild(btn);
      });
    }

    transitionMat.uniforms.uAspect.value = window.innerWidth / window.innerHeight;
    updateUI(); loadPanorama('block'); render(); 

  </script>
</body>
</html>
