<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voltaic - Depth Map Transition & Displacement</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>

<script type="module">
  import * as THREE from 'three';

  // 1. SETUP & TARGETS FOR TRANSITION
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  // Position camera inside the box
  camera.position.set(0, 0, 0.1); 
  
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Standard lighting required for MeshStandardMaterial to be visible
  const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
  scene.add(ambientLight);

  // Render targets with Depth Textures to feed the transition shader
  const targetParams = {
    minFilter: THREE.LinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBAFormat,
    depthTexture: new THREE.DepthTexture()
  };
  const oldTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, targetParams);
  const newTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, targetParams);

  // 2. THE DEPTH-AWARE BLOCK TRANSITION SHADER
  const transitionShader = {
    uniforms: {
      tOld: { value: null },
      tNew: { value: null },
      tDepth: { value: null },
      uProgress: { value: 0.0 },
      uBlockSize: { value: 40.0 },
      uAspect: { value: window.innerWidth / window.innerHeight },
      uHasDepth: { value: false }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D tOld;
      uniform sampler2D tNew;
      uniform sampler2D tDepth;
      uniform float uProgress;
      uniform float uBlockSize;
      uniform float uAspect;
      uniform bool uHasDepth;
      varying vec2 vUv;

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      void main() {
        vec2 correctedUv = vec2(vUv.x * uAspect, vUv.y);
        vec2 blockUv = floor(correctedUv * uBlockSize) / uBlockSize;
        
        float noise = hash(blockUv);
        float depthVal = 0.5; // Neutral fallback if no depth exists
        
        if (uHasDepth) {
          depthVal = texture2D(tDepth, vUv).r; 
        }
        
        // Combine noise and depth. Closer objects dissolve first.
        float threshold = noise * 0.4 + (1.0 - depthVal) * 0.6;
        
        if (smoothstep(0.0, 1.0, uProgress) > threshold) {
          gl_FragColor = texture2D(tNew, vUv);
        } else {
          gl_FragColor = texture2D(tOld, vUv);
        }
      }
    `
  };

  const transitionQuad = new THREE.Mesh(
    new THREE.PlaneGeometry(2, 2),
    new THREE.ShaderMaterial(transitionShader)
  );
  const transitionScene = new THREE.Scene();
  const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  transitionScene.add(transitionQuad);

  // 3. CUBEMAP & DEPTH ROUTING
  function getCubemap(loc, options = {}) {
    const isDepth = options.isDepth || false;
    const type = loc.type;
    const baseUrl = loc.baseUrl || 'vr2/';

    if (type === 'voltaic') {
      const ext = isDepth ? '-depth.jpeg' : '.jpeg';
      return [
        baseUrl + 'ENCHnodes-280' + ext, // Right (px)
        baseUrl + 'ENCHnodes-281' + ext, // Left (nx)
        baseUrl + 'ENCHnodes-282' + ext, // Top (py)
        baseUrl + 'ENCHnodes-278' + ext, // Bottom (ny)
        baseUrl + 'ENCHnodes-277' + ext, // Front (pz) 
        baseUrl + 'ENCHnodes-279' + ext  // Back (nz)
      ];
    }
    
    if (type === 'img-seq') {
      const b = baseUrl + 'cubemapvr/';
      return [
        b + 'IMG_5232.jpeg', b + 'IMG_5231.jpeg', b + 'IMG_5233.jpeg',
        b + 'IMG_5229.jpeg', b + 'IMG_5228.jpeg', b + 'IMG_5230.jpeg'
      ];
    }
    
    return [];
  }

  // 4. TRUE GEOMETRY DISPLACEMENT ROOM
  const textureLoader = new THREE.TextureLoader();
  let currentRoom = null;

  function createRoom(loc) {
    // Highly subdivided box for physical 3D parallax
    const geometry = new THREE.BoxGeometry(100, 100, 100, 128, 128, 128); 
    
    const colorUrls = getCubemap(loc, { isDepth: false });
    const hasDepth = loc.type === 'voltaic'; 
    const depthUrls = hasDepth ? getCubemap(loc, { isDepth: true }) : null;

    const materials = [];

    for (let i = 0; i < 6; i++) {
      const colorTex = textureLoader.load(colorUrls[i]);
      colorTex.colorSpace = THREE.SRGBColorSpace;
      
      const matParams = {
        map: colorTex,
        side: THREE.BackSide,
        roughness: 1.0, 
        metalness: 0.0
      };

      if (hasDepth && depthUrls) {
        const depthTex = textureLoader.load(depthUrls[i]);
        matParams.displacementMap = depthTex;
        // Push walls correctly to create physical parallax
        matParams.displacementScale = -15.0; 
      }

      materials.push(new THREE.MeshStandardMaterial(matParams));
    }

    return new THREE.Mesh(geometry, materials);
  }

  // 5. TRANSITION LOGIC & RENDER LOOP
  let isTransitioning = false;
  let transitionProgress = 0.0;
  let newRoom = null;
  let currentLocation = null;

  function triggerTransition(newLoc) {
    if (isTransitioning) return;
    
    isTransitioning = true;
    transitionProgress = 0.0;
    newRoom = createRoom(newLoc);
    
    transitionQuad.material.uniforms.uHasDepth.value = (currentLocation && currentLocation.type === 'voltaic');
    currentLocation = newLoc;
  }

  function animate() {
    requestAnimationFrame(animate);

    // Simple camera pan to show off the displacement parallax
    camera.rotation.y += 0.001;

    if (isTransitioning) {
      transitionProgress += 0.01; 
      transitionQuad.material.uniforms.uProgress.value = transitionProgress;

      if (currentRoom) {
        scene.add(currentRoom);
        renderer.setRenderTarget(oldTarget);
        renderer.render(scene, camera);
        scene.remove(currentRoom);
      }

      scene.add(newRoom);
      renderer.setRenderTarget(newTarget);
      renderer.render(scene, camera);

      transitionQuad.material.uniforms.tOld.value = oldTarget.texture;
      transitionQuad.material.uniforms.tNew.value = newTarget.texture;
      transitionQuad.material.uniforms.tDepth.value = oldTarget.depthTexture;

      renderer.setRenderTarget(null);
      renderer.render(transitionScene, orthoCamera);

      if (transitionProgress >= 1.0) {
        isTransitioning = false;
        if (currentRoom) {
          currentRoom.geometry.dispose();
          currentRoom.material.forEach(m => {
            if (m.map) m.map.dispose();
            if (m.displacementMap) m.displacementMap.dispose();
            m.dispose();
          });
        }
        currentRoom = newRoom;
      }
    } else {
      if (currentRoom) {
        scene.add(currentRoom);
        renderer.setRenderTarget(null);
        renderer.render(scene, camera);
        scene.remove(currentRoom);
      }
    }
  }

  // Handle window resizing
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    oldTarget.setSize(window.innerWidth, window.innerHeight);
    newTarget.setSize(window.innerWidth, window.innerHeight);
    transitionQuad.material.uniforms.uAspect.value = window.innerWidth / window.innerHeight;
  });

  // Kickoff Default Scene
  const voltaicLoc = { type: 'voltaic', baseUrl: 'vr2/' };
  currentLocation = voltaicLoc;
  currentRoom = createRoom(voltaicLoc);
  animate();

  // Uncomment to test a transition after 3 seconds
  // setTimeout(() => {
  //   triggerTransition({ type: 'img-seq', baseUrl: 'vr2/' });
  // }, 3000);

</script>
</body>
</html>
